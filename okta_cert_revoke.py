#!/usr/bin/env python3
"""
revoke_okta_unbound_certs_local.
"""

# #!/usr/bin/python3
#
# Copyright 2018-present, Okta Inc.
#
# Script to revoke client certificates per device #
# https://help.okta.com/en/prod/Content/Topics/Miscellaneous/Third-party%20Licenses/ 3rd%20Party%20Notices_Okta%20Password%20Sync%20Setup.pdf
#
# APIs used in this process are internal APIs and they are subject to changes without prior notice. #


# Hello Todd,
#
# ████████ from Okta here, hope everything is well. Apologies for the delay, last week I had to research this further to better understand the situation here and see what solutions are available for the issue and with yesterday being Juneteenth, I wasn't able to reach back sooner.
#
# It appears we do not have public facing documentation regarding this issue. I have reached out internally and the internal team has provided a python script to reset the limit you are having issues with. Please see below:
#
# https://github.com/isaiahtech/revoke_device_trust_okta/blob/main/okta_cert_revoke.py
#
# Please make sure that you replace the variable correct:
# SERVER = 'https://DOMAIN.okta.com'  # <----- Put your Okta tenant domain here
# okta_org_api_token = 'SSWS APIKEY_HERE'  # <----- Put your Admin API Key here !!! DO NOT DELETE SSWS !!!
# MAC_UDID = 'MAC_UDID_HERE'          # <----- Put your MacID here
#
# The following information must be gathered prior to executing script:
#
# SERVER = < Your tenant name 'https://.okta.com' >
# okta_org_api_token = 'SSWS <API_TOKEN>' # eg. 'SSWS ███████████████████████████████████' <An API token must be generated by navigating to the tenant's admin console -> Security -> API -> Tokens>
# MAC_UDID = '' # eg. '████████-████-████-████-████████████'/ This information can be found by clicking "About this Mac" -> System report
#
# Please let me know once you had the chance to test it out and let me know if it helps with removing the limit!
#
# Thank You,
#
# ████████ ████████
# Technical Support Engineer
# Okta Global Customer Care

# ╰─ ./okta_local_revoke_unbound_EC.py
# Getting certs for device: ████████-████-████-████-████████████
# Response: b'[{"kid":"███████████████████████████████████████","status":"VALID"},{"kid":"█████████████████████████████████████████","status":"VALID"},{"kid":"████████████████████████████████████████","status":"VALID"},{"kid":"████████████████████████████████████████","status":"VALID"},{"kid":"████████████████████████████████████████","status":"VALID"}]'
# Revoking certificate: ████████████████████████████████████████
# Response: b'{"kid":"████████████████████████████████████████","status":"REVOKED"}'
# Finished
# Revoking certificate: ████████████████████████████████████████
# Response: b'{"kid":"████████████████████████████████████████","status":"REVOKED"}'
# Finished
# Revoking certificate: ████████████████████████████████████████
# Response: b'{"kid":"████████████████████████████████████████","status":"REVOKED"}'
# Finished
# Revoking certificate: ████████████████████████████████████████
# Response: b'{"kid":"████████████████████████████████████████","status":"REVOKED"}'
# Finished
# Revoking certificate: ████████████████████████████████████████
# Response: b'{"kid":"████████████████████████████████████████","status":"REVOKED"}'
# Finished
#

import argparse
import json
import subprocess
import sys
import requests
from local_credentials import okta_root, okta_org_api_token

# okta_root = 'emersoncollective'
# okta_org_api_token = '████████-█████████-███████████████████████'


def fetch_local_uuid():
    """
    Returns local UUID of machine running script.
    """
    local_hardware_raw = subprocess.run('/usr/sbin/system_profiler SPHardwareDataType -json', shell=True, check=True, capture_output=True, encoding='utf-8')
    hardware = json.loads(local_hardware_raw.stdout)
    local_uuid = hardware['SPHardwareDataType'][0]['platform_UUID']

    return local_uuid


def get_and_revoke_certs(args, working_uuid):
    """
    Fetches currently allocated certs and schedules them for demolition
    """
    url = f"https://{okta_root}.okta.com/api/v1/internal/devices/{working_uuid}/credentials/keys"
    print(f'Getting certs for device: {working_uuid}')

    okta_headers = {'Content-Type': 'application/json', 'Accept': 'application/json', 'Authorization': f'SSWS {okta_org_api_token}'}
    response = requests.get(url=url, headers=okta_headers, timeout=5)
    response_json = response.json()

    if not response_json:
        print('No certificates found')
        sys.exit(0)
    else:
        print(f"Found {len(response_json)} cert(s).")

    for okta_cert in response_json:

        if 'kid' not in okta_cert.keys():
            print("Error in certs")
            sys.exit(1)
        print(okta_cert['status'], okta_cert['kid'])
        if not args.list_certs:
            revoke_this_cert(working_uuid, okta_cert['kid'])
        print('Finished.')


def revoke_this_cert(working_uuid, cert_id):
    """
    Revokes specific cert.
    """
    url = f'https://{okta_root}.okta.com/api/v1/internal/devices/{working_uuid}/keys/{cert_id}/lifecycle/revoke'
    print('Revoking certificate: ' + str(cert_id))

    okta_headers = {'Accept': 'application/json', 'Authorization': f'SSWS {okta_org_api_token}'}
    response = requests.post(url=url, headers=okta_headers, timeout=5)

    if response.status_code != 200:
        print(f"Error deleting {cert_id}! Code:{response.status_code}")
    else:
        print(f"Deleted {cert_id} successfully.")


def main():
    """
    ...
    """

    parser = argparse.ArgumentParser(
        prog='revoke_unbound_okta_certs.py',
        description='Revokes unbound Okta certs to reset 5 cert limit.',
        epilog='https://github.com/lazymutt/revoke_device_trust_okta is forked from https://github.com/isaiahtech/revoke_device_trust_okta')

    parser.add_argument('-t', '--target_uuid', action='store', default=None, help='UUID of machine you are targeting, otherwise the UUID of the machine the script is running on.')
    parser.add_argument('-l', '--list_certs', action="store_true", default=False, help='List unbound certificates.')

    args = parser.parse_args()

    if args.target_uuid:
        working_uuid = args.target_uuid
    else:
        working_uuid = fetch_local_uuid()

    get_and_revoke_certs(args, working_uuid)


if __name__ == '__main__':
    main()
